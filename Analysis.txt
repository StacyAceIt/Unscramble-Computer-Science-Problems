--------------------------------------------------------TASK0------------------------------------------------------------------------


# Task0 runtime analysis

print("First record of texts, %s texts %s at time %s" % (texts[0][0], texts[0][1], texts[0][2]))
print("Last record of calls, %s calls %s at time %s, lasting %s seconds"
      % (calls[-1][0], calls[-1][1], calls[-1][2], calls[-1][3]))

The first print takes O(3) because it retrieves three values texts[0][0], texts[0][1] and texts[0][2] by index.
The second print takes O(4) because it retrieves four values calls[-1][0], calls[-1][1], calls[-1][2] and calls[-1][3] by index.
The entire code take O(3)+O(4) = O(7). The order of growth of this algorithm is O(1).

--------------------------------------------------------TASK1---------------------------------------------------------------------

# Task1 runtime analysis

list_of_phone_numbers = []

for row in texts:           //n times
    if row[0] not in list_of_phone_numbers:  //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[0]) // 1 time
    if row[1] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[1]) // 1 time

//this part takes O(n * 2(n + 1)) = O(2n^2+2n)

for row in calls: // n times
    if row[0] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[0]) // 1 time
    if row[1] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[1])  // 1 time

//this part takes O(n * 2(n + 1)) = O(2n^2+2n)
//the entire algorithm takes O(2n^2+2n) + O(2n^2+2n) = O(4n^2 + 4n) which approximate to O(n^2)
//the order of growth of this algorithm is O(n^2)

----------------------------------------------------TASK2----------------------------------------------------------------------------

# Task2 runtime analysis

max_total_time = 0 // 1 time
max_record_index = None // 1 time
for record_index, record in enumerate(calls): // n times
    if int(record[3]) > int(max_total_time): // 1 time
        max_total_time = record[3]          // 1 time
        max_record_index = record_index      // 1 time

telephone_number = calls[max_record_index][0] // 1 time

print("%s spent the longest time, %s seconds, on the phone during September 2016."
      % (telephone_number, max_total_time))    // 2 times to retrieve two values

// the entire code takes O(3n + 5) which approximates to O(n)
//the order of growth of this algorithm is O(n)

-------------------------------------------------TASK3-------------------------------------------------------------------------------


# Task3 runtime analysis


texts_df = pd.DataFrame(texts, columns=['sender', 'receiver', 'timestamp'])  // 1 time
calls_df = pd.DataFrame(calls, columns=['caller', 'receiver', 'timestamp', 'duration']) // 1 time

calls_from_Bangalore = list()   // 1 time
Bangalore_to_Bangalore = 0  // 1 time

for index, caller in enumerate(calls_df['caller']): // n times
    if "(080)" in caller:   // n times
        calls_from_Bangalore.append(calls_df['receiver'][index])    // 1 time
        if "(080)" in calls_df['receiver'][index]:  // n times
            Bangalore_to_Bangalore += 1 // 1 time

calls_from_Bangalore_sorted_set = sorted(set(calls_from_Bangalore)) // 1 time
print("The numbers called by people in Bangalore have codes:\n") // 1 time
print("\n".join(calls_from_Bangalore_sorted_set)) // 1 time

percentage = Bangalore_to_Bangalore/len(calls_from_Bangalore) // 1 time

print("{:.2f} percent of calls from fixed lines in Bangalore are calls to other fixed lines in Bangalore."
      .format(percentage))   // 1 time

O(4 + n(2n+2) + 5) = O(2n^2 + 2n + 9) which approximates to O(n^2)
The order of growth of this algorithm is O(n^2)





----------------------------------------------------TASK4----------------------------------------------------------------------------



# Task4 runtime analysis

texts_df = pd.DataFrame(texts, columns=['sender', 'receiver', 'timestamp']) // 1 time
calls_df = pd.DataFrame(calls, columns=['caller', 'receiver', 'timestamp', 'duration']) // 1 time

telemarketer_set = set() // 1 time
for caller in calls_df['caller']:  // n times
    if (caller not in calls_df['receiver']) \    // search for caller takes n times
       and (caller not in texts_df['sender']) \  // search for caller takes n times
            and (caller not in texts_df['receiver']):  // search for caller takes n times. these add up to 3n times
        telemarketer_set.add(caller)  // 1 time

telemarketer_set = sorted(telemarketer_set) // 1 time

print("These numbers could be telemarketers: ") // 1 time
for i in telemarketer_set:  // n time
    print(i) // 1 time

O(3 + n * (3n+1) + 2 + n * 1) = O(5 + 5n^2) which approximates to O(n^2)
The growth of order of this algorithm is O(n^2)