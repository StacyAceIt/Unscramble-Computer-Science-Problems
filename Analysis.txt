--------------------------------------------------------TASK0------------------------------------------------------------------------


# Task0 runtime analysis

print("First record of texts, %s texts %s at time %s" % (texts[0][0], texts[0][1], texts[0][2]))
print("Last record of calls, %s calls %s at time %s, lasting %s seconds"
      % (calls[-1][0], calls[-1][1], calls[-1][2], calls[-1][3]))

There are two lines of code which takes O(2).
The order of growth of this algorithm is O(1).

--------------------------------------------------------TASK1---------------------------------------------------------------------

# Task1 runtime analysis

list_of_phone_numbers = []

for row in texts:           //n times
    if row[0] not in list_of_phone_numbers:  //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[0]) // 1 time
    if row[1] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[1]) // 1 time

//this part takes O(n * 2(n + 1)) = O(2n^2+2n)

for row in calls: // n times
    if row[0] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[0]) // 1 time
    if row[1] not in list_of_phone_numbers: //O(n) to check if row[0] exist in list_of_phone_numbers
        list_of_phone_numbers.append(row[1])  // 1 time

//outside for loop, one line of code takes O(1)
//for loop itself take O(n) and the four lines of code inside for loop takes O(2(n+1)).
//"row[0] not in list_of_phone_numbers" takes O(n) because it takes n times to check if a value exists in a list
//each for loop takes O(n * 2(n + 1)) = O(2n^2+2n)
//the entire algorithm takes O(2n^2+2n) + O(2n^2+2n) + O(1) = O(4n^2 + 4n + 1) which approximate to O(n^2)
//the order of growth of this algorithm is O(n^2)

----------------------------------------------------TASK2----------------------------------------------------------------------------

# Task2 runtime analysis

max_total_time = 0 // 1 time
max_record_index = None // 1 time
for record_index, record in enumerate(calls): // n times
    if int(record[3]) > int(max_total_time): // 1 time
        max_total_time = record[3]          // 1 time
        max_record_index = record_index      // 1 time

telephone_number = calls[max_record_index][0] // 1 time

print("%s spent the longest time, %s seconds, on the phone during September 2016."
      % (telephone_number, max_total_time))    // 1 time

// Outside for loop, 4 lines of code takes O(4). Inside for loop, it takes O(3*n)
// It totals to O(3n+4)
//the order of growth of this algorithm is O(n)

-------------------------------------------------TASK3-------------------------------------------------------------------------------


# Task3 runtime analysis

calls_from_Bangalore = list()   // 1 time
Bangalore_to_Bangalore = 0  // 1 time

index = 0 // 1 time
for call_record in calls:    //n times
    caller = call_record[0]     // 1 time
    receiver = call_record[1]       // 1 time
    if "(080)" in caller:           // O(n) to check substring in worst case
        calls_from_Bangalore.append(receiver)   // 1 time
        if "(080)" in receiver:     // O(n) to check substring in worst case
            Bangalore_to_Bangalore += 1  // 1 time
    index += 1  1 time

calls_from_Bangalore_sorted_set = sorted(set(calls_from_Bangalore)) // 1 time
print("The numbers called by people in Bangalore have codes:\n") // 1 time
print("\n".join(calls_from_Bangalore_sorted_set)) // 1 time

percentage = Bangalore_to_Bangalore/len(calls_from_Bangalore) // 1 time

print("{:.2f} percent of calls from fixed lines in Bangalore are calls to other fixed lines in Bangalore."
      .format(percentage))   // 1 time

It is O(8) outside for loop and there is O(n*(2n+5)) inside for loop which totals to O(2n^2+5n+8)
this algorithm approximates to O(n^2)
The order of growth of this algorithm is O(n^2)


----------------------------------------------------TASK4----------------------------------------------------------------------------



# Task4 runtime analysis

text_sender = []  // 1 time
text_receiver = []  // 1 time
call_receiver = []  // 1 time
for index, text_record in enumerate(texts): // n times
    text_sender.append(text_record[0])  // 1 time
    text_receiver.append(text_record[1]) // 1 time
    if index < len(calls): // 1 time
        call_receiver.append(calls[index][1]) // 1 time

telemarketer_list = list()  // 1 time
for call_record in calls: // n times
    caller = call_record[0] // 1 time
    if (caller not in text_sender) and (caller not in text_receiver)
    and (caller not in call_receiver):      // n + n + n = 3n times
        telemarketer_list.append(caller) // 1 time

telemarketer_sorted_set = sorted(set(telemarketer_list))  // 1 time

print("These numbers could be telemarketers: ")  // 1 time
print("\n".join(telemarketer_sorted_set))  // 1 time



Outside for loop, 7 lines of code takes O(7)
The first for loop takes O(4*n)
The second for loop takes O(n * (3n + 2)) times
The entire code takes O(3n^2 + 6n + 7) which approximates to O(n^2)
The order of growth is O(n^2)